import sys
from collections import deque

input = sys.stdin.readline

# ------------------------------------------------------------
# 백준 24526 (전화 돌리기) 풀이 아이디어
#
# 핵심:
# - 전화 전달을 "방향 그래프"로 본다. (u -> v)
# - 누군가가 전화를 "두 번 이상" 받게 되는 상황은
#   전달 과정에서 "사이클"이 존재할 때 발생한다.
# - 따라서 "안전하게 끝날 수 있는 사람" = 사이클에 속하지 않고,
#   사이클로 들어가지도 않는 사람.
#
# 해결 전략(가장 깔끔한 정답):
# 1) 간선을 뒤집은 역방향 그래프를 만든다.
# 2) 역방향 그래프에서 indegree(들어오는 간선 수)를 계산한다.
# 3) indegree가 0인 노드부터 큐로 제거(위상정렬)한다.
# 4) 제거된 노드 수가 곧 "안전한 사람 수" = 정답
#
# 직관:
# - indegree가 0인 노드는 "누구에게도 전화가 오지 않는" 노드(역방향 기준)라서
#   사이클과 무관하게 안전하게 제거 가능하다.
# - 이렇게 안전한 노드를 계속 걷어내면
#   끝까지 제거되지 못하고 남는 노드들은 사이클 관련 노드(사이클 내부/사이클로 유입)로 묶인다.
# - 따라서 제거된 개수가 우리가 원하는 답이 된다.
# ------------------------------------------------------------

N, M = map(int, input().split())

# rev[x] = 역방향 그래프에서 x -> (원래 그래프에서 x로 들어오던 노드들)
# 원래: u -> v
# 역방향: v -> u
rev = [[] for _ in range(N + 1)]

# indegree[i] = 역방향 그래프에서 i로 "들어오는" 간선 수
# (즉, 역방향에서 누가 i에게 연결되어 있는지의 개수)
indegree = [0] * (N + 1)

for _ in range(M):
    u, v = map(int, input().split())

    # 원래 u -> v 를 뒤집어서 v -> u 로 저장
    rev[v].append(u)

    # 역방향에서 u는 "들어오는 간선"이 하나 늘어남 (v -> u)
    indegree[u] += 1

# 위상정렬용 큐 준비:
# indegree가 0인 노드들은 "역방향에서 시작점"이므로 먼저 제거 가능
q = deque()
for i in range(1, N + 1):
    if indegree[i] == 0:
        q.append(i)

# cnt = 위상정렬로 제거(확정 안전)한 노드 개수
cnt = 0

# 큐가 빌 때까지:
# - 하나 꺼내서 안전 노드로 확정(제거)
# - 그 노드에서 나가는 간선을 따라 다음 노드들의 indegree 감소
# - 새로 indegree가 0이 되면 큐에 넣어 제거 진행
while q:
    cur = q.popleft()
    cnt += 1  # cur는 안전하게 제거됨

    # cur가 역방향에서 가리키는 nxt들은,
    # cur가 제거되면 nxt의 들어오는 간선(=cur -> nxt)이 사라지므로 indegree 감소
    for nxt in rev[cur]:
        indegree[nxt] -= 1
        if indegree[nxt] == 0:
            q.append(nxt)

# 위상정렬로 제거된 노드 수가 곧 정답
print(cnt)
