'''
A와 F
B와 E
C와 D
마주 봄

숫자는 1이상 50이하. 규칙 없음

N <= 1000000
N은 백 만 이하
N^3 은 매우 큰 수

보이는 면의 수의 합의 최솟값 출력
'''
'''
규칙 존재

1. 가장 아래줄
꼭짓점 4개의 블럭은 이어진 두 면이 보임
(N-2) * 4 개의 블럭은 하나의 면만 보임

2. 맨 윗줄
꼭짓점 4개의 블럭은 3개의 면만 보임(마주보지 않는)
(N-2) * 4 개의 블럭은 이어진 두 면이 보임
N*N - 4*(N-1) 개의 블럭은 한 면만 보임

3. 그 외
네 모서리에 존재하는 4 * (N-2)개의 블럭은 이어진 두 면이 보임
그 외 N*N - 4 * (N-1) 개의 블럭은 한 면만 보임

결국 블럭은 세 가지 타입으로 나눌 수 있음
1) 한 면만 보이는 블럭
6개의 수 중 최솟값 택하면 됨
2) 이어진 두 면이 보이는 블럭
가능한 두 수의 합 중 최솟값 선택(마주보는 두 면 제외)
3) 세 면이 보이는 블럭 (마주 보는 두 면 제외)
가능한 세 수의 합 중 최솟값 선
'''
'''
세 가지 타입에서
마주보는 두 수 중 하나만 사용 가능함
'''
N = int(input())
A,B,C,D,E,F = map(int, input().split())
dice = [A,B,C,D,E,F]
dice.sort()

# 1 X 1 X 1 주사위일 때
# 가장 큰 숫자 제외한 총합
if N == 1:
    print(sum(dice[:5]))

# 그 외
else:
    # 마주보는 두 수 중 작은 수만 사용
    min_1 = min(A,F)
    min_2 = min(B,E)
    min_3 = min(C,D)
    
    nums = [min_1,min_2,min_3]
    nums.sort()
    select_one = nums[0]            # 한 면 보이는 경우: 가장 작은 수
    select_two = nums[0]+nums[1]    # 두 면 보이는 경우: 작은 두 수의 합 
    select_three = sum(nums)        # 세 면 보이는 경우: 세 수의 합 
    
    ans = 0
    ans += select_one * (5*N*N - 16*N + 12)
    ans += select_two * (8*N -12)
    ans += select_three * 4
    print(ans)
