'''
세 자연수 n,x,y 가 주어짐

1부터 n까지의 자연수가 각 2개씩 있는 길이 2n짜리 랭퍼드 수열의 개수를 출력

단, x번째와 y번째 숫자가 같아야 함


예시)
3 1 4 가 주어진다면
1~3의 숫자가 각 2개씩 사용되고, 1번째와 4번째 숫자가 동일해야 함

생각해보자
1번째와 4번째 숫자가 같다는 것은 아주 중요한 조건
why?
1번째 숫자와 4번째 숫자 사이에는 2개의 숫자가 들어감
>> 1번째 숫자와 4번째 숫자는 1이 될 수 없다! 2만이 가능함!
2 _ _ 2 _ _ 까지 그려짐
2와 2 사이에는 1 1 불가능, 3 3도 불가능

가능한 경우는
2 3 1 2 1 3 뿐이다

3과 3 사이에는 3개의 숫자가 들어가야 한다
>> 3의 인덱스가 i 라면 다른 3의 인덱스는 i+4(or i-4)

'''
'''
위 예시를 통해 든 생각

x번째 수와 y번째 수는 알고 시작
둘 사이에 들어가는 숫자의 개수는 y-x-1개임 
>> x = y = y-x-1 

나머지 2n-2개의 숫자는 어떻게 배열할 수 있을까?

7 4 10
_ _ _ 5 _ _ _ _ _ 5 _ _ _ _

큰 숫자들부터 인덱스 앞에서부터 지정 
num = 7
i랑 i+num 같게, 두 인덱스에 이미 숫자가 있다면 다음으로
i+num이 2n이상이면 불가능 
'''

# 랭퍼드 수열 만드는 함수
# 현재 넣을 숫자 받아서 이어나감
# n부터 시작해서 1까지 수열에 다 넣었다면 경우의 수 1 증가
def backtrack(num):
    global ans

    # x,y번째 넣기로 한 수라면 다음 수로 넘어감
    if num == xth:
        backtrack(num-1)
        return

    # 현재 넣는 수가 0이라면 (1까지 다 넣었다면) 결과 1 증가
    if num == 0:
        ans += 1
        return

    # num을 넣을 인덱스
    # i번째와 i+num+1번째 자리에 num을 넣어야 함
    for i in range(1,2*n+1):
        # 두 숫자 중 나중에 오는 수의 인덱스가 길이를 벗어나면 안 됨
        if i+num+1 > 2*n:
            return

        # 이미 채워진 칸이라면 다음 칸으로
        if numbers[i] != 0 or numbers[i+num+1] != 0:
            continue

        # 동일한 두 숫자 삽입
        numbers[i] = numbers[i+num+1] = num

        # 다음 숫자 삽입
        backtrack(num-1)

        numbers[i] = numbers[i+num+1] = 0


n,x,y = map(int, input().split())

# 랭퍼드 수열
# idx = 0 은 사용하지 않을 예정
numbers = [0]*(2*n+1)

# x,y번째 자리에 들어갈 숫자
xth = y-x-1

# x, y 번째 수 지정
numbers[x] = xth
numbers[y] = xth

# 가능한 랭퍼드 수열 개수
ans = 0

backtrack(n)

print(ans)


