'''
구하고자 하는 것: 놓을 수 있는 파이프라인의 최대 개수

가스관과 빵집 연결하는 파이프 설치

가스관과 빵집 사이에 건물이 있는 경우 파이프 설치 불가

파이프라인은 첫째 열에서 시작, 마지막 열에서 끝

각 칸은 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선
3가지로 연결 가능

파이프라인끼리 겹칠 수도, 접할 수도 없음
각 칸을 지나는 파이프는 하나
'''

'''
1 <= R <= 10000 (행 개수)
5 <= C <= 500 (열 개수)
처음과 마지막 열은 항상 비어 있음
'''
'''
Greedy적 요소
- 파이프라인의 이동 가능 방향 제약 (우상, 우, 우하)
- 최대 개수를 구함

한 칸 당 하나의 파이프만 지날 수 있음
>> 각 파이프는 다른 파이프에 최소 영향을 줘야 함
>> 최상 파이프부터 시작 위쪽 경로부터 가능여부 파악하여 아래쪽 여유 최대로

이렇게 선택하면 하나의 경로 없앤다고 해서 두 개 이상의 경로가 가능하게 되지 않음

마지막 열에 도착할 때까지 진행
도착 전에 경로에 X가 있다면 끝
본인이 지나온 경로에 X 표시

'''
'''
첫 시행 시간초과 뜸
왜?
지나온 경로 표시를 해당 경로가 끝 지점까지 도착할 수 있을 때만 했음

but 해당 경로가 끝까지 도달하지 못한다면, 다른 경로 또한 해당 경로가 지나간 길을 갈 때
끝까지 도달하지 못할 것임.

그러므로 맨 위에서부터 우상, 우, 우하 순서를 지킨다면
지나온 경로 표시를 모두 해도 됨
'''

import sys
input = sys.stdin.readline

# 파이썬 기본 재귀 깊이 제한 1,000
# 본 문제는 10,000행이므로 재귀 깊이 설정
sys.setrecursionlimit(10**5)

def oneline(now_r, now_c):
    # 마지막 열 도달 시 끝
    if now_c == C-1:
        return True
    board[now_r][now_c] = 'x'
    # 다음 위치 (now_r-1,now_c+1) / (now_r, now_c+1) / (now_r+1, now_c+1)
    # 우상, 우, 우하 순서 >> 최선의 경우 순서임
    for dr in (-1,0,1):
        nr, nc = now_r + dr, now_c + 1
        # 현재 기준 다음 칸으로 이동 가능하다면
        if 0<= nr < R and 0<= nc < C and board[nr][nc] == '.':
            # 다음 칸에서도 끝까지 이동 가능한지 파악
            if oneline(nr,nc):
                # 세 방향 중 최선을 찾았다면 해당 출발점에서 다른 경로를 찾을 필요가 없음
                return True
    return False

R, C = map(int, input().split())
board = [list(input().strip()) for _ in range(R)]
count = 0

for row in range(R):
    if oneline(row,0):
        count += 1

print(count)
